// Package secrets orchestrates secret storage across OpenBao and .env backends.
// It handles the lifecycle: store during init/add, seed OpenBao on first up,
// and pull secrets back to a transient .env for Docker Compose.
package secrets

import (
	"context"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/fyltr/angee/internal/config"
	"github.com/fyltr/angee/internal/credentials"
	"github.com/fyltr/angee/internal/credentials/openbao"
)

// StoreSecret stores a secret in the best available backend.
// If OpenBao is configured and reachable, it stores there.
// Otherwise it falls back to the .env file.
// Returns the backend name used ("openbao" or "env").
func StoreSecret(ctx context.Context, cfg *config.AngeeConfig, rootPath, name, value string) (string, error) {
	if cfg.SecretsBackend != nil && cfg.SecretsBackend.Type == "openbao" && cfg.SecretsBackend.OpenBao != nil {
		bao := openbao.TryNew(cfg.SecretsBackend.OpenBao, cfg.Environment)
		if bao != nil {
			if err := bao.Set(ctx, name, value); err == nil {
				return "openbao", nil
			}
			// Fall through to .env on error
		}
	}

	envPath := envFilePath(rootPath)
	env := credentials.NewEnvBackend(envPath)
	if err := env.Set(ctx, name, value); err != nil {
		return "", fmt.Errorf("storing secret %q in .env: %w", name, err)
	}
	return "env", nil
}

// SeedOpenBao reads all secrets from the .env file and writes them to OpenBao
// using SetIfAbsent (OpenBao wins on conflicts). Returns the number of secrets seeded.
func SeedOpenBao(ctx context.Context, bao *openbao.Backend, envPath string) (int, error) {
	entries, err := loadEnvEntries(envPath)
	if err != nil {
		if os.IsNotExist(err) {
			return 0, nil
		}
		return 0, fmt.Errorf("reading .env: %w", err)
	}

	seeded := 0
	for envKey, value := range entries {
		secretName := envKeyToSecret(envKey)
		written, err := bao.SetIfAbsent(ctx, secretName, value)
		if err != nil {
			return seeded, fmt.Errorf("seeding %q: %w", secretName, err)
		}
		if written {
			seeded++
		}
	}
	return seeded, nil
}

// PullToEnvFile lists all secrets from OpenBao and writes a transient .env file.
// The generated file has a header indicating it's auto-generated.
// Returns the number of secrets written.
func PullToEnvFile(ctx context.Context, bao *openbao.Backend, envPath string) (int, error) {
	names, err := bao.List(ctx)
	if err != nil {
		return 0, fmt.Errorf("listing secrets: %w", err)
	}
	if len(names) == 0 {
		return 0, nil
	}

	entries := make(map[string]string, len(names))
	for _, name := range names {
		val, err := bao.Get(ctx, name)
		if err != nil {
			return 0, fmt.Errorf("reading secret %q: %w", name, err)
		}
		envKey := secretToEnvKey(name)
		entries[envKey] = val
	}

	var sb strings.Builder
	sb.WriteString("# AUTO-GENERATED by angee up — source of truth: OpenBao\n")
	sb.WriteString("# Do not edit manually. Changes will be overwritten on next angee up.\n\n")

	// Sort keys for deterministic output
	var keys []string
	for k := range entries {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		// Escape $ as $$ for Docker Compose
		val := strings.ReplaceAll(entries[k], "$", "$$")
		sb.WriteString(k + "=" + val + "\n")
	}

	if err := os.WriteFile(envPath, []byte(sb.String()), 0600); err != nil {
		return 0, fmt.Errorf("writing .env: %w", err)
	}
	return len(entries), nil
}

// secretToEnvKey converts "db-password" → "DB_PASSWORD".
func secretToEnvKey(name string) string {
	return strings.ToUpper(strings.ReplaceAll(name, "-", "_"))
}

// envKeyToSecret converts "DB_PASSWORD" → "db-password".
func envKeyToSecret(key string) string {
	return strings.ToLower(strings.ReplaceAll(key, "_", "-"))
}

// envFilePath returns the .env path within an ANGEE_ROOT.
func envFilePath(rootPath string) string {
	return rootPath + "/.env"
}

// loadEnvEntries parses a .env file into key=value pairs, skipping comments and blanks.
func loadEnvEntries(path string) (map[string]string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	entries := make(map[string]string)
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		if idx := strings.IndexByte(line, '='); idx > 0 {
			key := line[:idx]
			val := line[idx+1:]
			// Unescape $$ → $ (Docker Compose escaping)
			val = strings.ReplaceAll(val, "$$", "$")
			entries[key] = val
		}
	}
	return entries, nil
}
